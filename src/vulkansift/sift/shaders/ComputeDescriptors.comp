#version 450

#define NB_HIST 4
#define NB_ORI 8

#define LAMBDA_DESCRIPTOR 3.0f
#define L2_NORM_THRESHOLD 0.2f
#define PI 3.14159265358979323846

struct SIFT_Feat {
  float x;
  float y;
  uint orig_x;
  uint orig_y;
  uint index_scale;
  float sigma;
  float scale_factor;
  float theta;
  float value;
  uint feature_vector[(NB_HIST*NB_HIST*NB_ORI)/4];
};

layout(local_size_x = 64) in;
layout(r32f, binding = 0) uniform image2DArray octave_input;
layout(std430, binding = 1) buffer SIFT_buffer {
    uint nb_elem;
    SIFT_Feat data[];
};

float getImVal(int scale_idx, int x, int y) {
    return imageLoad(octave_input, ivec3(x, y, scale_idx)).r;
}

void main() {
    int idx = int(gl_GlobalInvocationID.x);
    SIFT_Feat kp = data[idx];

    int image_width = imageSize(octave_input).x;
    int image_height = imageSize(octave_input).y;

    float scaled_lambda_desc = LAMBDA_DESCRIPTOR * (kp.sigma / kp.scale_factor);
    float radius = sqrt(2.f) * scaled_lambda_desc *(NB_HIST+1) * 0.5;
    int int_radius = int(radius);

    float keypoint_cos = cos(kp.theta)/scaled_lambda_desc;
    float keypoint_sin = sin(kp.theta)/scaled_lambda_desc;

    float expf_scale = -1.f / (2.f * (NB_HIST/2) * (NB_HIST/2));
    float work_feat_vect[NB_HIST*NB_HIST*NB_ORI];
    for(int i=0; i<NB_HIST*NB_HIST*NB_ORI;i++) {
        work_feat_vect[i] = 0;
    }
    for (int i = 0; i < (NB_HIST*NB_HIST*NB_ORI)/4; i++)
    {
        kp.feature_vector[i] = 0;
    }

    for (int delta_x = -int_radius; delta_x <= int_radius; delta_x++)
    {
        for (int delta_y = -int_radius; delta_y <= int_radius; delta_y++)
        {
            int idx_x = int(kp.x) + delta_x;
            int idx_y = int(kp.y) + delta_y;

            if(idx_x<1 || idx_x>=(image_width-1) || idx_y<1 || idx_y>=(image_height-1)) {
                continue;
            }

            // Rotate indexes by keypoint orientation
            float oriented_x = keypoint_cos * float(delta_x) + keypoint_sin * float(delta_y);
            float oriented_y = keypoint_cos * float(delta_y) - keypoint_sin * float(delta_x);

            float gradX = 0.5f * (getImVal(int(kp.index_scale), idx_x+1, idx_y) - getImVal(int(kp.index_scale), idx_x-1, idx_y));
            float gradY = 0.5f * (getImVal(int(kp.index_scale), idx_x, idx_y+1) - getImVal(int(kp.index_scale), idx_x, idx_y-1));
            float orientation = atan(gradY,gradX)-kp.theta;
            // Cap orientation in [0, 2xPI]
            if(orientation<0) {
                orientation += 2.f*PI;
            }
            else if(orientation > (2.f*PI)) {
                orientation -= 2.f*PI;
            }
            float mag = exp(expf_scale * ((oriented_x * oriented_x) + (oriented_y * oriented_y)))*sqrt((gradX*gradX)+(gradY*gradY));

            // Compute histogram indexes
            float fhist_x_idx = oriented_x + (NB_HIST/2) -0.5;
            float fhist_y_idx = oriented_y + (NB_HIST/2) -0.5;
            float fbin_idx = orientation * float(NB_ORI) / (2.f * PI);
            if (fhist_x_idx < 0 || fhist_x_idx>=NB_HIST || fhist_y_idx < 0 || fhist_y_idx>=NB_HIST)
            {
                continue;
            }
            int hist_x_idx = int(floor(fhist_x_idx));
            int hist_y_idx = int(floor(fhist_y_idx));

            // Disperse contribution into the two nearest histograms and bins
            for (int i = hist_x_idx; i < hist_x_idx + 2; i++)
            {
                for (int j = hist_y_idx; j < hist_y_idx + 2; j++)
                {
                    if(i>= 0 && i<NB_HIST && j>=0 && j<NB_HIST) {
                        int bin_idx_left = (int(orientation) % NB_ORI + NB_ORI) % NB_ORI;
                        work_feat_vect[j * NB_HIST * NB_ORI + i * NB_ORI + bin_idx_left] +=
                            (1.f - abs(i - fhist_x_idx)) * (1.f - abs(j - fhist_y_idx)) * (1.f - abs(floor(fbin_idx) - fbin_idx)) * mag;

                        int bin_idx_right = (int(orientation) % NB_ORI + NB_ORI + 1) % NB_ORI;
                        work_feat_vect[j * NB_HIST * NB_ORI + i * NB_ORI + bin_idx_right] +=
                            (1.f - abs(i - fhist_x_idx)) * (1.f - abs(j - fhist_y_idx)) * (1.f - abs(floor(fbin_idx) + 1.f - fbin_idx)) * mag;
                    }
                }
            }
        }
    }



    // Post processing step on feature vector

    // Saturate features to a threshold of the feature vector L2 norm

    // COMPUTE EUCLIDEAN NORM
    float eucliean_norm = 0.f;
    for (int i = 0; i < NB_HIST * NB_HIST * NB_ORI; i++)
    {
        eucliean_norm += (work_feat_vect[i] * work_feat_vect[i]);
    }
    eucliean_norm = sqrt(eucliean_norm);
    for (int i = 0; i < NB_HIST * NB_HIST * NB_ORI; i++)
    {
        work_feat_vect[i] = min(work_feat_vect[i], (eucliean_norm * L2_NORM_THRESHOLD));
    }

    eucliean_norm = 0.f;
    for (int i = 0; i < NB_HIST * NB_HIST * NB_ORI; i++)
    {
        eucliean_norm += (work_feat_vect[i] * work_feat_vect[i]);
    }
    eucliean_norm = sqrt(eucliean_norm);
    for (int i = 0; i < (NB_HIST*NB_HIST*NB_ORI)/4; i++)
    {
        uint feat_val = 0;
        for(int j=0; j<4; j++) {
            work_feat_vect[(i*4)+j] = work_feat_vect[(i*4)+j] * (512.f / eucliean_norm);
            if (work_feat_vect[(i*4)+j] < 0.f)
            {
                // Do nothing since it's already 0
                //feat_val |= 0u;
            }
            else if (work_feat_vect[(i*4)+j] > 255.f)
            {
                feat_val |= 255<<(8*j);
            }
            else
            {
                feat_val |= uint(work_feat_vect[(i*4)+j])<<(8*j);
            }
        }
        kp.feature_vector[i] = feat_val;
    }
    data[idx] = kp;
}