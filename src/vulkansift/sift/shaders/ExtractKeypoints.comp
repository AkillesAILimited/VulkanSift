#version 450

#define NB_HIST 4
#define NB_ORI 8

struct SIFT_Feat {
  float x;
  float y;
  uint orig_x;
  uint orig_y;
  uint index_scale;
  float sigma;
  float scale_factor;
  float theta;
  float value;
  uint feature_vector[(NB_HIST*NB_HIST*NB_ORI)/4];
};

layout(local_size_x = 8, local_size_y = 8) in;
layout(r32f, binding = 0) uniform image2D dog_input;
layout(std430, binding = 1) buffer SIFT_buffer {
    uint nb_elem;
    SIFT_Feat data[];
};
layout(std430, binding = 2) buffer IndispatchBuffer {
    uint nb_x_group;
    uint nb_y_group;
    uint nb_z_group;
};

layout(push_constant) uniform PushConst {
  uint offset_y;
  float scale_factor;
  float sigma_multiplier;
  float soft_dog_threshold;
  float dog_threshold;
  float edge_threshold;
} push_const;


float getVal(int scale_idx, int x, int y) {
    return imageLoad(dog_input, ivec2(x, y + (scale_idx*push_const.offset_y))).r;
}
void main() {

    int x = int(gl_GlobalInvocationID.x);
    int y = int(gl_GlobalInvocationID.y);
    int s = int(gl_GlobalInvocationID.z+1);

    // Check 3x3x3 neighborhood (x/y/s)
    float center_value = getVal(s, x, y);
    bool is_best_in_neighborhood = (abs(center_value)>push_const.soft_dog_threshold) && ((
    //bool is_best_in_neighborhood = ((
                 center_value > getVal(s,   x-1,    y) &&
                 center_value > getVal(s,   x+1,    y) &&
                 center_value > getVal(s,   x-1,    y-1) &&
                 center_value > getVal(s,   x,      y-1) &&
                 center_value > getVal(s,   x+1,    y-1) &&
                 center_value > getVal(s,   x-1,    y+1) &&
                 center_value > getVal(s,   x,      y+1) &&
                 center_value > getVal(s,   x+1,    y+1) &&
                 // Superior prev scale
                 center_value > getVal(s-1, x-1,    y) &&
                 center_value > getVal(s-1, x,      y) &&
                 center_value > getVal(s-1, x+1,    y) &&
                 center_value > getVal(s-1, x-1,    y-1) &&
                 center_value > getVal(s-1, x,      y-1) &&
                 center_value > getVal(s-1, x+1,    y-1) &&
                 center_value > getVal(s-1, x-1,    y+1) &&
                 center_value > getVal(s-1, x,      y+1) &&
                 center_value > getVal(s-1, x+1,    y+1) &&
                 // Superior next scale
                 center_value > getVal(s+1, x-1,    y) &&
                 center_value > getVal(s+1, x,      y) &&
                 center_value > getVal(s+1, x+1,    y) &&
                 center_value > getVal(s+1, x-1,    y-1) &&
                 center_value > getVal(s+1, x,      y-1) &&
                 center_value > getVal(s+1, x+1,    y-1) &&
                 center_value > getVal(s+1, x-1,    y+1) &&
                 center_value > getVal(s+1, x,      y+1) &&
                 center_value > getVal(s+1, x+1,    y+1)) || // OR
                // Inferior curr scale
                (
                 center_value < getVal(s,   x-1,    y) &&
                 center_value < getVal(s,   x+1,    y) &&
                 center_value < getVal(s,   x-1,    y-1) &&
                 center_value < getVal(s,   x,      y-1) &&
                 center_value < getVal(s,   x+1,    y-1) &&
                 center_value < getVal(s,   x-1,    y+1) &&
                 center_value < getVal(s,   x,      y+1) &&
                 center_value < getVal(s,   x+1,    y+1) &&
                 // Inferior prev scale
                 center_value < getVal(s-1, x-1,    y) &&
                 center_value < getVal(s-1, x,      y) &&
                 center_value < getVal(s-1, x+1,    y) &&
                 center_value < getVal(s-1, x-1,    y-1) &&
                 center_value < getVal(s-1, x,      y-1) &&
                 center_value < getVal(s-1, x+1,    y-1) &&
                 center_value < getVal(s-1, x-1,    y+1) &&
                 center_value < getVal(s-1, x,      y+1) &&
                 center_value < getVal(s-1, x+1,    y+1) &&
                 // Inferior next scale
                 center_value < getVal(s+1, x-1,    y) &&
                 center_value < getVal(s+1, x,      y) &&
                 center_value < getVal(s+1, x+1,    y) &&
                 center_value < getVal(s+1, x-1,    y-1) &&
                 center_value < getVal(s+1, x,      y-1) &&
                 center_value < getVal(s+1, x+1,    y-1) &&
                 center_value < getVal(s+1, x-1,    y+1) &&
                 center_value < getVal(s+1, x,      y+1) &&
                 center_value < getVal(s+1, x+1,    y+1)));

    //is_best_in_neighborhood = abs(center_value)>0.01;

    if(is_best_in_neighborhood) {

        // Refine keypoint
        bool has_converged = false;
        float offset_X = 0.f;
        float offset_Y = 0.f;
        float offset_S = 0.f;
        int step_cnt = 0;
        int refined_x = x;
        int refined_y = y;
        int refined_s = s;

        for (step_cnt = 0; step_cnt < 5; step_cnt++)
        {
            // Check if point is in image boundaries otherwise stop ?
            // Compute offset from gradient and Hessian

            // Gradient
            float gS = 0.5f * (getVal(refined_s+1,refined_x,refined_y) - getVal(refined_s-1,refined_x,refined_y));
            float gX = 0.5f * (getVal(refined_s,refined_x+1,refined_y) - getVal(refined_s,refined_x-1,refined_y));
            float gY = 0.5f * (getVal(refined_s,refined_x,refined_y+1) - getVal(refined_s,refined_x,refined_y-1));
            // Hessian
            float h11 = getVal(refined_s+1,refined_x,refined_y) + getVal(refined_s-1,refined_x,refined_y) - 2.f * getVal(refined_s,refined_x,refined_y);
            float h22 = getVal(refined_s,refined_x+1,refined_y) + getVal(refined_s,refined_x-1,refined_y) - 2.f * getVal(refined_s,refined_x,refined_y);
            float h33 = getVal(refined_s,refined_x,refined_y+1) + getVal(refined_s,refined_x,refined_y-1) - 2.f * getVal(refined_s,refined_x,refined_y);

            float h12 = 0.25f * (getVal(refined_s+1,refined_x+1,refined_y) - getVal(refined_s+1,refined_x-1,refined_y) -
                                 getVal(refined_s-1,refined_x+1,refined_y) + getVal(refined_s-1,refined_x-1,refined_y));
            float h13 = 0.25f * (getVal(refined_s+1,refined_x,refined_y+1) - getVal(refined_s+1,refined_x,refined_y-1) -
                                 getVal(refined_s-1,refined_x,refined_y+1) + getVal(refined_s-1,refined_x,refined_y-1));
            float h23 = 0.25f * (getVal(refined_s,refined_x+1,refined_y+1) - getVal(refined_s,refined_x+1,refined_y-1) -
                                 getVal(refined_s,refined_x-1,refined_y+1) + getVal(refined_s,refined_x-1,refined_y-1));

            // Inverted Hessian
            float determinant = h11 * ((h22 * h33) - (h23 * h23)) - h12 * ((h12 * h33) - (h13 * h23)) + h13 * ((h12 * h23) - (h13 * h22));
            if (determinant != 0.0f)
            {
                float inv_h11 = ((h22 * h33) - (h23 * h23)) / determinant;
                float inv_h12 = -1.f * ((h12 * h33) - (h13 * h23)) / determinant;
                float inv_h13 = ((h12 * h23) - (h13 * h22)) / determinant;

                float inv_h22 = ((h11 * h33) - (h13 * h13)) / determinant;
                float inv_h23 = -1.f * ((h11 * h23) - (h13 * h12)) / determinant;
                float inv_h33 = ((h11 * h22) - (h12 * h12)) / determinant;

                offset_S = -inv_h11 * gS - inv_h12 * gX - inv_h13 * gY;
                offset_X = -inv_h12 * gS - inv_h22 * gX - inv_h23 * gY;
                offset_Y = -inv_h13 * gS - inv_h23 * gX - inv_h33 * gY;
            }
            else
            {
                // No solution for this
                break;
            }
            if (abs(offset_X) < 0.5f && abs(offset_Y) < 0.5f && abs(offset_S) < 0.5f)
            {
                // If all offset under 0.6 we can stop here, extremum is at (pos x_idx,y_idx,scale_idx)
                has_converged = true;
                break;
            }
            else
            {
                refined_x = x + int(round(offset_X));
                refined_y = y + int(round(offset_Y));
                refined_s = s + int(round(offset_S));
            }
        }
        if(has_converged) {
            float gS = 0.5f * (getVal(refined_s+1,refined_x,refined_y) - getVal(refined_s-1,refined_x,refined_y));
            float gX = 0.5f * (getVal(refined_s,refined_x+1,refined_y) - getVal(refined_s,refined_x-1,refined_y));
            float gY = 0.5f * (getVal(refined_s,refined_x,refined_y+1) - getVal(refined_s,refined_x,refined_y-1));
            float new_val = getVal(refined_s,refined_x,refined_y) + 0.5f * (gX * offset_X + gY * offset_Y + gS * offset_S);
            if(abs(new_val) > push_const.dog_threshold) {
                float h11 = getVal(refined_s,refined_x+1,refined_y) + getVal(refined_s,refined_x-1,refined_y) - 2.f * getVal(refined_s,refined_x,refined_y);
                float h22 = getVal(refined_s,refined_x,refined_y+1) + getVal(refined_s,refined_x,refined_y-1) - 2.f * getVal(refined_s,refined_x,refined_y);
                float h12 = 0.25f * (getVal(refined_s,refined_x+1,refined_y+1) - getVal(refined_s,refined_x+1,refined_y-1) -
                    getVal(refined_s,refined_x-1,refined_y+1) + getVal(refined_s,refined_x-1,refined_y-1));
                float edgeness = (pow(h11, 2.f) + pow(h22, 2.f)) / ((h11 * h22) - (h12 * h12));
                if (edgeness <= (pow(push_const.edge_threshold + 1, 2.0f) / push_const.edge_threshold))
                {
                    uint idx = atomicAdd(nb_elem, 1);
                    if (idx % 64 == 0) {
                        atomicAdd(nb_x_group, 1);
                    }
                    data[idx].x = refined_x;
                    data[idx].y = refined_y;
                    data[idx].index_scale = uint(round(float(refined_s)+offset_S));
                    data[idx].scale_factor = push_const.scale_factor;
                    data[idx].sigma = push_const.sigma_multiplier* pow(2.f, float(refined_s+offset_S)/float(gl_NumWorkGroups.z));
                    data[idx].theta = 0.f;
                    data[idx].orig_x = uint(round(push_const.scale_factor*float(data[idx].x)));
                    data[idx].orig_y = uint(round(push_const.scale_factor*float(data[idx].y)));
                    data[idx].value = new_val;
                }
            }
        }




        /*uint idx = atomicAdd(nb_elem, 1);
        data[idx].x = gl_GlobalInvocationID.x;
        data[idx].y = gl_GlobalInvocationID.y;
        data[idx].index_scale = gl_GlobalInvocationID.z+1;
        data[idx].scale_factor = push_const.scale_factor;
        data[idx].sigma = push_const.sigma_multiplier* pow(2.f, float(data[idx].index_scale)/float(gl_NumWorkGroups.z));
        data[idx].theta = 0.f;
        data[idx].orig_x = uint(round(push_const.scale_factor*float(data[idx].x)));
        data[idx].orig_y = uint(round(push_const.scale_factor*float(data[idx].y)));
        data[idx].value = center_value;*/
    }


}